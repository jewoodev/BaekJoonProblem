# [Silver V] 소수 - 2581 

[문제 링크](https://www.acmicpc.net/problem/2581) 

### 성능 요약

메모리: 30616 KB, 시간: 816 ms

### 분류

수학(math), 정수론(number_theory), 소수 판정(primality_test)

### 문제 설명

<p>자연수 M과 N이 주어질 때 M이상 N이하의 자연수 중 소수인 것을 모두 골라 이들 소수의 합과 최솟값을 찾는 프로그램을 작성하시오.</p>

<p>예를 들어 M=60, N=100인 경우 60이상 100이하의 자연수 중 소수는 61, 67, 71, 73, 79, 83, 89, 97 총 8개가 있으므로, 이들 소수의 합은 620이고, 최솟값은 61이 된다.</p>

### 입력 

 <p>입력의 첫째 줄에 M이, 둘째 줄에 N이 주어진다.</p>

<p>M과 N은 10,000이하의 자연수이며, M은 N보다 작거나 같다.</p>

### 출력 

 <p>M이상 N이하의 자연수 중 소수인 것을 모두 찾아 첫째 줄에 그 합을, 둘째 줄에 그 중 최솟값을 출력한다. </p>

<p>단, M이상 N이하의 자연수 중 소수가 없을 경우는 첫째 줄에 -1을 출력한다.</p>

## 풀고난 후

그리디 방식으로 접근했다. 아직 부족한 부분이 많은 탓에 굉장히 많이 틀려가면서 반례가 무엇인지 들여다보고 제출하기를 반복했다.  
출력 방식이 잘못되었다고 처음에 떠서 "\n"을 사용해 출력값 두가지를 줄바꿈하는 걸 바꿨고, 결과는 "틀렸습니다." 로 바뀌었다. 어디가 잘못된 것인지... 출력이 아직도 잘못되고 있는게 아닌가 하는 생각에 출력값의 타입도 살펴보았었다.  
고민이 이어지고, '출력 부분이 아닌 곳에서 문제가 생기는 것이다.' 라고 판단했고 주어진 입력값 외에 의심되는 값들을 입력해보기 시작했다. if문에서 continue가 주어지고 나누어지는 수일때 넘어가고 다음 수가 나누어지는지 찾게 되어있었는데 그러면 나누어지는 수가 있는 만큼 해당 수가 리스트에 추가되는 코드인걸 알아차리고 break문으로 바꾸었다. 지금은 기억이 정확하지 않아 정확한 절차는 아닐 수도 있다.  
디버깅을 하면서, 그리고 백준의 질문게시판에 있는 반례에 대한 글들을 살펴보며 내 코드에는 어떤 반례가 있을지 오래 고민하였다. 그러다가 소수로 2를 세어야 하는 상황에서 세지 않는 것을 발견했고 코드를 어떻게 고쳐서 반례를 없앨지 고민했었다. 긴 시간 끝에 답을 구해냈다.

다른 풀이들을 보니 나는 그리디하게 푼게 아니구나, 생각하게 됐다. 조건문과 반복문을 딱딱하게 쓰고 있는걸 느꼈다. 그리고 순서를 어떻게 쓰느냐에 따라 코드의 효율성이 달라지는 걸 많이 느낄 수 있었다. 그리고 어떻게 파이썬 문장에서 컴퓨터가 작동하는지 이해도가 부족한 것을 느낀다.